---
title: "Introduction to Simulation-based Inference"
author: "Aaron A. King and Edward L. Ionides"
output:
  html_document:
    toc: yes
    toc_depth: 4
bibliography: ../sbied.bib
csl: ../ecology.csl
nocite: |
  @King2008, @Romero-Severson2015, @He2010, 
  @Laneri2010, @King2015
---

\newcommand\prob[1]{\mathbb{P}\left[{#1}\right]}
\newcommand\expect[1]{\mathbb{E}\left[{#1}\right]}
\newcommand\var[1]{\mathrm{Var}\left[{#1}\right]}
\newcommand\dist[2]{\mathrm{#1}\left(#2\right)}
\newcommand\dlta[1]{{\Delta}{#1}}
\newcommand\lik{\mathcal{L}}
\newcommand\loglik{\ell}

[Licensed under the Creative Commons Attribution-NonCommercial license](http://creativecommons.org/licenses/by-nc/4.0/).
Please share and remix noncommercially, mentioning its origin.  
![CC-BY_NC](../graphics/cc-by-nc.png)

Produced in **R** version `r getRversion()` using **pomp2** version `r packageVersion("pomp2")`.

```{r knitr-opts,include=FALSE,purl=FALSE,cache=FALSE}
library(knitr)
prefix <- "intro"
opts_chunk$set(
  progress=TRUE,
  prompt=FALSE,tidy=FALSE,highlight=TRUE,
  strip.white=TRUE,
  warning=FALSE,
  message=FALSE,
  error=FALSE,
  echo=TRUE,
  cache=TRUE,
  cache.extra=list(rand_seed,R.version.string),
  results='markup',
  fig.show='asis',
  size='small',
  fig.lp="fig:",
  fig.path=paste0("figure/",prefix,"-"),
  cache.path=paste0("cache/",prefix,"-"),
  fig.pos="h!",
  fig.align='center',
  fig.height=4,fig.width=6.83,
  dpi=100,
  dev='png',
  dev.args=list(bg='transparent')
  )
options(
  keep.source=TRUE,
  encoding="UTF-8"
  )
# library(knitcitations)
# cleanbib()
# options(citation_format="pandoc")
```
```{r opts,include=FALSE,cache=FALSE}
options(stringsAsFactors=FALSE)
library(ggplot2)
theme_set(theme_bw())
set.seed(2028866059L)
```

--------

--------

## Introduction: ecological and epidemiological dynamics

- Ecological systems are complex, open, nonlinear, and nonstationary.
- "Laws of Nature" are unavailable except in the most general form.
- It is useful to model them as stochastic systems.
- For any observable phenomenon, multiple competing explanations are possible.
- Central scientific goals:
    - Which explanations are most favored by the data?
    - Which kinds of data are most informative?
- Central applied goals:
    - How to design ecological or epidemiological intervention?
    - How to make accurate forecasts?
- Time series are particularly useful sources of data.

<br>

-----

-----

### Noisy clockwork: Time series analysis of population fluctuations in animals

##### Six problems of @Bjornstad2001

Obstacles for **ecological** modeling and inference via nonlinear mechanistic models:

1. Combining measurement noise and process noise.
2. Including covariates in mechanistically plausible ways.
3. Using continuous-time models.
4. Modeling and estimating interactions in coupled systems. 
5. Dealing with unobserved variables.
6. Modeling spatial-temporal dynamics.

The same issues arise for **epidemiological** modeling and inference via nonlinear mechanistic models.

The *partially observed Markov process* modeling framework we focus on in this course addresses most of these problems effectively.

<br>

------

------

## Objectives

1. To show how stochastic dynamical systems models can be used as scientific instruments.
1. To teach statistically and computationally efficient approaches for performing scientific inference using POMP models.
1. To give students the ability to formulate models of their own.
1. To give students opportunities to work with such inference methods.
1. To familiarize students with the **pomp** package.
1. To provide documented examples for adaptation and re-use.

<br>

-------

-------

## Questions and answers

1. [How to explain the resurgence of pertussis in countries with sustained high vaccine coverage?](https://doi.org/10.1126/scitranslmed.aaj1748)
1. [What roles are played by asymptomatic infection and waning immunity in cholera epidemics?](http://dx.doi.org/10.1038/nature07084)
1. [How long does pertussis vaccine protection last and how does it fail?](https://doi.org/10.1017/S0031182015000979)
3. [What explains the seasonality of measles?](http://dx.doi.org/10.1098/rsif.2009.0151)
7. [Do subclinical infections of pertussis play an important epidemiological role?](http://dx.doi.org/10.1371/journal.pone.0072086)
2. [What is the contribution to the HIV epidemic of dynamic variation in sexual behavior of an individual over time? How does this compare to the role of heterogeneity between individuals?](http://dx.doi.org/10.1093/aje/kwv044)
5. [What explains the interannual variability of malaria?](http://dx.doi.org/10.1371/journal.pcbi.1000898)
6. [What will happen next in an Ebola outbreak?](http://dx.doi.org/10.1098/rspb.2015.0347)
1. [Can hydrology explain the seasonality of cholera?](http://doi.org/10.1016/j.advwatres.2016.11.012)
1. [What is the contribution of adults to polio transmission?](http://doi.org/10.1073/pnas.1323688111)

<br>

------------

-----------

## Partially observed Markov process (POMP) models

* Data $y^*_1,\dots,y^*_N$ collected at times $t_1<\dots<t_N$ are modeled as noisy, incomplete, and indirect observations of a Markov process $\{X(t), t\ge t_0\}$.

* This is a __partially observed Markov process (POMP)__ model, also known as a hidden Markov model or a state space model.

* $\{X(t)\}$ is Markov if the history of the process, $\{X(s), s\le t\}$, is uninformative about the future of the process, $\{X(s), s\ge t\}$, given the current value of the process, $X(t)$. 

* If all quantities important for the dynamics of the system are placed in the __state__, $X(t)$, then the Markov property holds by construction.

* Systems with delays can usually be rewritten as Markovian systems, at least approximately.

* An important special case: any system of differential equations is Markovian.

* POMP models can include all the features desired by @Bjornstad2001.

<br>

-----------------

------------------------------

### Schematic of the structure of a POMP

- Arrows in the following diagram show causal relations.
   
<img src="pomp_schematic1.png" width="400" />

```{r ssdiag1,echo=FALSE,purl=FALSE,fig.height=3,fig.width=6,fig.show='hide'}
library(grid)
library(gridExtra)
vp <- viewport(x=unit(0.5,"npc"),y=unit(0.54,"npc"),
               width=unit(0.5,"npc"),height=unit(0.5,"npc"))
pushViewport(vp)

grid.ellipse(x=0.5,y=0.2,angle=0,ar=2.5,size=20,gp=gpar(lwd=2,col='black'))
grid.text(x=0.5,y=0.2,label="state process",gp=gpar(fontsize=12,fontface='bold'))

grid.ellipse(x=0.2,y=0.7,angle=0,ar=2.5,size=18,gp=gpar(lwd=2,col='black'))
grid.text(x=0.2,y=0.7,label="measurement\n process",gp=gpar(fontsize=12,fontface='bold'))

grid.ellipse(x=0.7,y=0.8,angle=0,ar=1.5,size=16,gp=gpar(lwd=2,col='black'))
grid.text(x=0.7,y=0.8,label="data",gp=gpar(fontsize=12,fontface='bold'))

popViewport()
```

- A key perspective to keep in mind is that **the model is to be viewed as the process that generated the data**.


<br>

---------------------

---------------------

#### Notation for partially observed Markov process models

* Write $X_n=X(t_n)$ and $X_{0:N}=(X_0,\dots,X_N)$. Let $Y_n$ be a random variable modeling the observation at time $t_n$.

* The one-step transition density, $f_{X_n|X_{n-1}}(x_n|x_{n-1};\theta)$, together with the measurement density, $f_{Y_n|X_n}(y_n|x_n;\theta)$ and the initial density, $f_{X_0}(x_0;\theta)$, specify the entire joint density via

$$f_{X_{0:N},Y_{1:N}}(x_{0:N},y_{1:N};\theta) = f_{X_0}(x_0;\theta)\,\prod_{n=1}^N\!f_{X_n | X_{n-1}}(x_n|x_{n-1};\theta)\,f_{Y_n|X_n}(y_n|x_n;\theta).$$

* The marginal density for sequence of measurements, $Y_{1:N}$, evaluated at the data, $y_{1:N}^*$, is

$$ f_{Y_{1:N}}(y^*_{1:N};\theta)=\int f_{X_{0:N},Y_{1:N}}(x_{0:N},y^*_{1:N};\theta)\, dx_{0:N}.$$

<br>

------------------------------

------------------------------

### Another POMP model schematic

- In the following diagram, arrows show dependence among model variables:

```{r ssdiag2,echo=FALSE,purl=FALSE,fig.height=3,fig.width=6}
library(grid)
vp <- viewport(x=unit(0.5,"npc"),y=unit(0.54,"npc"),
               width=unit(0.96,"npc"),height=unit(0.96,"npc"))
pushViewport(vp)

fs <- 12
x1 <- 0.6; y1 <- 0.88
gp <- gpar(lty=2,col=grey(0.6),fontsize=12)
grid.text(x=x1,y=y1,label="measurement model",just="centre",gp=gpar(fontsize=fs,col=grey(0.6)))
grid.lines(x=unit(c(x1,3/12),"npc")+unit(c(0,2),"points"),y=unit(c(y1,1/2),"npc")+unit(c(-fs/2,0),"points"),gp=gp)
grid.lines(x=unit(c(x1,6/12),"npc")+unit(c(0,2),"points"),y=unit(c(y1,1/2),"npc")+unit(c(-fs/2,0),"points"),gp=gp)
grid.lines(x=unit(c(x1,8/12),"npc")+unit(c(0,-2),"points"),y=unit(c(y1,1/2),"npc")+unit(c(-fs/2,0),"points"),gp=gp)
grid.lines(x=unit(c(x1,10/12),"npc")+unit(c(0,-2),"points"),y=unit(c(y1,1/2),"npc")+unit(c(-fs/2,0),"points"),gp=gp)

x1 <- 0.4; y1 <- 0.14
grid.text(x=x1,y=y1,label="process model",just="centre",gp=gp)
grid.lines(x=unit(c(x1,4/24),"npc"),y=unit(c(y1,1/3),"npc")+unit(c(fs/2,-fs/4),"points"),gp=gp)
grid.lines(x=unit(c(x1,23/72),"npc"),y=unit(c(y1,1/3),"npc")+unit(c(fs/2,-fs/4),"points"),gp=gp)
grid.lines(x=unit(c(x1,31/72),"npc"),y=unit(c(y1,1/3),"npc")+unit(c(fs/2,-fs/4),"points"),gp=gp)
grid.lines(x=unit(c(x1,14/24),"npc"),y=unit(c(y1,1/3),"npc")+unit(c(fs/2,-fs/4),"points"),gp=gp)
grid.lines(x=unit(c(x1,18/24),"npc"),y=unit(c(y1,1/3),"npc")+unit(c(fs/2,-fs/4),"points"),gp=gp)
grid.lines(x=unit(c(x1,65/72),"npc"),y=unit(c(y1,1/3),"npc")+unit(c(fs/2,-fs/4),"points"),gp=gp)

grid.text(x=1/72,y=c(1/3,2/3),label=c("states","observations"),just="centre",rot=90,gp=gp)

x1 <- unit(c(1,3,6,8,10,3,6,8,10)/12,"npc")
y1 <- unit(c(rep(1,5),rep(2,4))/3,"npc")
w <- unit(1/12,"npc")
h <- unit(1/6,"npc")

grid.lines(x=c(1/48,47/48),y=1/12,arrow=arrow(length=unit(0.02,"npc")))
grid.text(x=x1[1:5],y=1/24,label=c(expression(italic(t[0])),expression(italic(t[1])),expression(italic(t[n-1])),expression(italic(t[n])),expression(italic(t[n+1]))))

grid.rect(x=x1,y=y1,width=w,height=h,just=c(0.5,0.5),gp=gpar(fill="white",lwd=2))
grid.text(x=x1,y=y1,label=c(
  expression(italic(X[0])),expression(italic(X[1])),
  expression(italic(X[n-1])),expression(italic(X[n])),
  expression(italic(X[n+1])),
  expression(italic(Y[1])),expression(italic(Y[n-1])),
  expression(italic(Y[n])),expression(italic(Y[n+1]))),
  gp=gpar(fontface=3))
grid.text(x=c(4.5,11.5)/12,y=unit(1/3,"npc")+unit(2,"point"),label=quote(phantom(0)~cdots~phantom(0)),gp=gpar(fontsize=15))
grid.lines(x=c(1,3)/12+c(1,-1)/24,y=1/3,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=c(3,4)/12+c(1,1/3)/24,y=1/3,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=c(5,6)/12+c(-1/3,-1)/24,y=1/3,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=c(6,8)/12+c(1,-1)/24,y=1/3,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=c(8,10)/12+c(1,-1)/24,y=1/3,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=c(10,11)/12+c(1,1/3)/24,y=1/3,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=3/12,y=c(1,2)/3+c(1,-1)/12,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=6/12,y=c(1,2)/3+c(1,-1)/12,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=8/12,y=c(1,2)/3+c(1,-1)/12,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))
grid.lines(x=10/12,y=c(1,2)/3+c(1,-1)/12,arrow=arrow(length=unit(0.02,"npc")),gp=gpar(lwd=2))

popViewport()
```

- The state process, $X_n$, is Markovian, i.e.,

$$f_{X_n|X_{0:n-1},Y_{1:n-1}}(x_n|x_{0:n-1},y_{1:n-1})=f_{X_n|X_{n-1}}(x_n|x_{n-1}).$$

- Moreover, the measurable random variable, $Y_n$, depends only on the state at that time:
$$f_{Y_n|X_{0:N},Y_{1:n-1}}(y_n|x_{0:n},y_{1:n-1})=f_{Y_n|X_{n}}(y_n|x_n),$$
for all $n=1,\dots,N$.

<br>
 
-----------------

----------------

### Algorithms for POMP models

To think algorithmically, we define some function calls:

* `rprocess( )`: a draw from $f_{X_n|X_{n-1}}(x_n| x_{n-1};\theta)$

* `dprocess( )`: evaluation of $f_{X_n|X_{n-1}}(x_n| x_{n-1};\theta)$

* `rmeasure( )`: a draw from $f_{Y_n|X_n}(y_n| x_n;\theta)$

* `dmeasure( )`: evaluation of $f_{Y_n|X_n}(y_n| x_n;\theta)$

* `initializer( )`: a draw from $f_{X_0}(x_0;\theta)$

<br>

-------------

-------------

### What does it mean for methodology to be __simulation-based__?

* Simulating random processes is often much easier than evaluating their transition probabilities.

* In other words, we may be able to write `rprocess()` but not `dprocess()`.

*  __Simulation-based__ methods require the user to specify `rprocess()` but not `dprocess()`.

* __Plug-and-play__, __likelihood-free__ and __equation-free__ are alternative terms for "simulation-based" methods.

* Much development of simulation-based statistical methodology has occurred in the past decade.

<br>

------------

------------

## The **pomp2** package for POMP models

* **pomp2** is an  **R**  package for data analysis using partially observed Markov process (POMP) models.

* Note the distinction: lower case '**pomp2**' is a software package; upper case 'POMP' is a class of models.

* **pomp2** builds methodology for POMP models in terms of arbitrary user-specified POMP models.

* **pomp2** provides tools, documentation, and examples to help users specify POMP models.

* **pomp2** provides a platform for modification and sharing of models, data-analysis workflows, and methodological development.

* It is useful to divide the **pomp2** package functionality into different levels:
	- basic model components
	- workhorses
	- elementary POMP algorithms
	- estimation algorithms

<br>

---------

---------

### Basic model components and workhorses

*Basic model components* are user-specified procedures that perform the elementary computations that specify a POMP model.
There are nine of these:

- `rinit`: simulator for the initial-state distribution, i.e., the distribution of the latent state at time `t0`.
- `rprocess` and `dprocess`: simulator and density evaluation procedure, respectively, for the process model.
- `rmeasure` and `dmeasure`: simulator and density evaluation procedure, respectively, for the measurement model.
- `rprior` and `dprior`: simulator and density evaluation procedure, respectively, for the prior distribution.
- `skeleton`: evaluation of the deterministic skeleton.
- `partrans`: parameter transformations.

The term *basic model component* is meant to refer to the procedure itself, as distinct from the execution of the procedure.
The user specifies the procedure (in one of several forms);
the package decides when and where to execute the procedure.

*Workhorses* are **R** functions, built into the package, that cause the basic model component procedures to be executed.
Each workhorse has a name that matches that of the corresponding basic model component.
In addition, there is the `trajectory` workhorse, which iterates or integrates the deterministic skeleton (according to whether it is a map or a vectorfield, respectively) to obtain state trajectories. 

<br>

---------

---------

### Elementary POMP algorithms

These are algorithms that interrogate the model or the model/data confrontation without attempting to estimate parameters.
There are currently four of these:

- `simulate` performs simulations of the POMP model, i.e., it samples from the joint distribution of latent states and observables.
- `pfilter` runs a sequential Monte Carlo (particle filter) algorithm to compute the likelihood and (optionally) estimate the prediction and filtering distributions of the latent state process.
- `probe` computes one or more uni- or multi-variate summary statistics on both actual and simulated data.
- `spect` estimates the power spectral density functions for the actual and simulated data.

<br>

---------

---------

## POMP estimation algorithms

These are procedures that build on the elementary algorithms and are used for estimation of parameters and other inferential tasks.
There are currently ten of these:

- `abc`: approximate Bayesian computation
- `bsmc2`: Liu-West algorithm for Bayesian SMC
- `pmcmc`: a particle MCMC algorithm
- `mif2`: iterated filtering (IF2)
- `enkf`, `eakf` ensemble and ensemble adjusted Kalman filters
- `traj_objfun`: trajectory matching
- `spect_objfun`: power spectrum matching
- `probe_objfun`: probe matching
- `nlf_objfun`: nonlinear forecasting

- *Objective function methods*: 
among the estimation algorithms just listed, four are methods that construct stateful objective functions that can be optimized using general-purpose numerical optimization algorithms such as `optim`, `subplex`, or the optimizers in the **nloptr** package.
These have certain new features that will be described below.

<br>

---------

---------

### **pomp2** vs **pomp**

Because **pomp2** contains changes that are not backward-incompatible with **pomp** versions <2, it is being made available initially in source and binary formats as a separate package via the https://kingaa.github.io/ package repository.
Thus it is possible for users to have both **pomp** (version <2) and **pomp2** installed simultaneously as they transition their workflows to the new version.
It is anticipated that, around the middle of 2019, **pomp2** will be renamed **pomp** and uploaded to CRAN as version 2.1.
From that point forward, **pomp2** will be discontinued as a separate package and there will be no ongoing support for older versions of **pomp**.

<br>

---------

---------


------------------------------

## [Back to course homepage](../index.html)

----------------------

## References
